#include <bits/stdc++.h>
using namespace std;

vector<int> v = {0}; // 고정석의 번호
int d[45]; // 연속된 자리의 개수가 i개일 때 앉을 수 있는 경우의 수

int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);
  
  int n, m, vv;
  cin >> n;
  cin >> m;
  while (m--) {
    cin >> vv;
    v.push_back(vv);
  }
  v.push_back(n + 1);

  d[0] = 1;
  d[1] = 1;
  d[2] = 2;
  for (int i = 3; i <= n; i++) d[i] = d[i - 1] + d[i - 2];

  int ans = 1;
  for (int i = 1; i < v.size(); i++) ans *= d[v[i] - v[i - 1] - 1];
  cout << ans; 
}

/*
d[0]의 경우 연속해서 vip자리가 자리를 잡으면 그때는 그 사이를 비집고
자리를 잡아서 앉을 수 있는 경우의 수는 없는데, 
문제를 푸는데 있어서 d[0]의 수를 연산 과정상 곱해주어야 하고, 
결국 자리에 앉지 못한다는 경우의 수 1가지가 있어서 그걸 곱해서 그대로
연산 결과에 영향을 미치지 않게 만들면 이 문제를 문제없이 해결할 수 있다
그래서 vip가 연달아서 안지 않은 예 에서는 d[0]=1;을 제거해도 정답이 나오지만,
만약 연달아서 박아넣으면 d[0]=1; 항을 제거해서 d[0] 항을 정의하지 않거나 
지금같은 경우 전역변수로 잡아서 0으로 초기화 되어있다면, 문제가 정답이 나오지 않는다. 

*/


/*
앉을 수 있는 경우의 수는 마지막 자리에 i번이 앉거나 마지막에서 두번째 자리부터 차례대로
i번과 i - 1번이 앉는 두 가지 경우밖에 없으므로 d[i] = d[i - 1] + d[i - 2]이 되어 피보나치 수열을 이룸
*/